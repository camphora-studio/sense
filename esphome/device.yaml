esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

json:

globals:
  - id: aqm_is_pairing
    type: bool
    initial_value: 'false'

script:
  - id: broadcast_pairing_request
    mode: restart # Ensures only one pairing process runs at a time.
    then:
      - lambda: 'id(aqm_is_pairing) = true;'
      # Loop 20 times with a 3s delay, for a total timeout of 1 minute.
      - repeat:
          count: 20
          then:
            - if:
                condition:
                  lambda: 'return id(aqm_is_pairing);'
                then:
                  - logger.log: "Broadcasting PAIR_REQ..."
                  - espnow.broadcast:
                      data: !lambda |-
                        char buffer[128];
                        snprintf(buffer, sizeof(buffer), "{\"msg_type\":\"PAIR_REQ\", \"sender_mac\":\"%s\"}", esphome::get_mac_address_pretty().c_str());
                        std::string str_buffer = buffer;
                        return std::vector<unsigned char>(str_buffer.begin(), str_buffer.end());
                  - delay: 3s
      # After the loop, check if we timed out.
      - if:
          condition:
            lambda: 'return id(aqm_is_pairing);'
          then:
            - logger.log: "Pairing timed out. No PAIR_ACK received."
            - lambda: 'id(aqm_is_pairing) = false;'

espnow:
  auto_add_peer: false
  on_unknown_peer:
    - lambda: |-
        auto body = std::string(reinterpret_cast<const char*>(data), size);
        json::parse_json(body, [&](JsonObject root) -> bool {
          // Use a safer, type-aware check for the message type.
          if (id(aqm_is_pairing) && root["msg_type"].is<const char*>() && root["msg_type"] == "PAIR_ACK") {
            ESP_LOGI("pairing", "SUCCESS! PAIR_ACK received from %s.", format_mac_address_pretty(info.src_addr).c_str());
            id(aqm_is_pairing) = false;
            return true;
          }
          return false;
        });

binary_sensor:
  # Upper Button (GPIO9) - Sends Level 1 (Low Concern)
  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true
    name: "DISPLAY Button"
    filters:
      # This is the correct filter for debouncing.
      # It waits 20ms before setting the state to ON.
      - delayed_on: 20ms
    on_press:
      then:
        - logger.log: "Button A (L1) pressed. Sending VOC=150, NOx=20"
        - espnow.broadcast:
            data: '{"msg_type":"DATA", "voc_index":150, "nox_index":20}'

  # Middle Button (GPIO0) - Sends Level 3 (High Concern)
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: "RESUME Button"
    filters:
      - delayed_on: 20ms
    on_press:
      then:
        - logger.log: "Button B (L3) pressed. Sending VOC=400, NOx=300"
        - espnow.broadcast:
            data: '{"msg_type":"DATA", "voc_index":100, "nox_index":10}'

  # Lower Button (GPIO1) - Handles Pairing Request
  - platform: gpio
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
      inverted: true
    name: "PAIR/RESET Button"
    filters:
      - delayed_on: 20ms
    on_click:
      min_length: 2s
      max_length: 10s
      then:
        - logger.log: "PAIR/RESET button held. Starting pairing broadcast..."
        # The button's only job is to start the main script.
        - script.execute: broadcast_pairing_request

