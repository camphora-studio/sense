esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

espnow:


binary_sensor:
  # Upper Button (GPIO9) - Sends Level 1 (Low Concern)
  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true
    name: "DISPLAY Button"
    filters:
      # This is the correct filter for debouncing.
      # It waits 20ms before setting the state to ON.
      - delayed_on: 20ms
    on_press:
      then:
        - logger.log: "Button A (L1) pressed. Sending VOC=150, NOx=20"
        - espnow.broadcast:
            data: '{"msg_type":"DATA", "voc_index":150, "nox_index":20}'

  # Middle Button (GPIO0) - Sends Level 3 (High Concern)
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: "RESUME Button"
    filters:
      - delayed_on: 20ms
    on_press:
      then:
        - logger.log: "Button B (L3) pressed. Sending VOC=400, NOx=300"
        - espnow.broadcast:
            data: '{"msg_type":"DATA", "voc_index":100, "nox_index":10}'

  # Lower Button (GPIO1) - Handles Pairing Request
  - platform: gpio
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
      inverted: true
    name: "PAIR/RESET Button"
    filters:
      - delayed_on: 20ms
    on_click:
      min_length: 2s
      max_length: 10s
      then:
        - logger.log: "PAIR/RESET button held. Broadcasting PAIR_REQ."
        - espnow.broadcast:
            data: !lambda |-
              char buffer[128];
              snprintf(buffer, sizeof(buffer), "{\"msg_type\":\"PAIR_REQ\", \"sender_mac\":\"%s\"}",
                       esphome::get_mac_address_pretty().c_str());
              // Create a std::string from our buffer
              std::string str_buffer = buffer;
              // Return the required vector of bytes from the string's contents
              return std::vector<unsigned char>(str_buffer.begin(), str_buffer.end());
